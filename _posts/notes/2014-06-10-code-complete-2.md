---
layout:	default
title:  《代码大全2》读书笔记
---

《代码大全》是有关编程分割和软件构建的绝好指导书。

# 第一部分 打好基础

## chp01 欢迎进入软件构建的世界

+ 构建活动主要关注于 编码与调试，也部分包含 详设、单测、集成测试。
+ 不同程序员的效率相差20倍。你的效率高么?

## chp02 软件隐喻

+ writing code
+ growing a system
+ system accretion
+ build software

## chp03 前期准备

程序员是软件食物链的最后一环。架构师吃掉需求，设计师吃掉架构，程序员消化设计


## chp04 关键的构建决策

选择代码，定好编程规范

# 第二部分 高质量代码

## chp05 软件构建中的设计
设计不是在谁的头脑中直接跳出来的，它是在不断的设计评估、非正式讨论、写实验代码以及修改试验代码中演化和完善的。

软件本质 复杂，管理复杂度

理想的设计特征

+ 最小复杂度
+ 易于维护
+ 松散耦合
+ 可扩展性
+ 可重用性
+ 搞扇入
+ 低扇出
+ 可移植性
+ 精简性
+ 层次性
+ 标准技术

设计的层次

+ 系统
+ 子系统（业务规则，数据库访问）
+ 类
+ 子程序（类的私有方法）
+ 子程序内部（数据结构，算法，编程）

对状态变量的使用

1. 不要使用布尔，使用枚举
2. 使用access routine来取代对状态变量的直接检查。

设计模式：关于设计启发的总结  P108

Refs：《设计模式》《重构》《怎样解题》（波利亚）

设计实践：
+ 迭代
+ Bottom Up
+ Top Down

## chp06 Working Classes

抽象数据类型：深入挖掘能在问题领域工作的能量吧！

好的抽象：

+ 类的接口需要提供一致的抽象，函数之间最好是有联系的，内聚的。
+ 提供成对的服务。
+ 把不相关的信息转移到其他类中。
+ 尽可能让接口可编程，而不是表达语义。 少用语义假设
+ 不要在修改的时候引入新接口，破坏原有抽象。大杂烩
+ 抽象性和内聚性往往一起出现。

良好的封装:

+ 尽可能限制可访问性
+ 不要公开暴露成员数据
+ 不要将private实现public
+ 不要对使用者做假设
+ 避免使用友元
+ 不要因为一个函数只使用了公共函数，就设为public
+ 让代码阅读起来比编写方便
+ 警惕从语义上破坏封装
+ 当心耦合

包含：

+ 包含才是面向对象编程中的主力技术
+ 数据成员 7+-2

继承：

+ 使用public继承表示 is-a
+ 最好不要用，如果要用，详细的写说明
+ Liskov替换原则
+ 不要覆盖一个非virtual函数，即使你可以那么做，因为那意味着不合理的使用
+ 不要超过3层继承，子类不要超过7个
+ 派生后，将某个子函数覆盖，让他什么都不做。可以考虑让父类使用组合来灵活描述行为。猫和爪子
+ 使用多态。
+ 使用private，而不是protected

成员函数和数据成员：

+ 子程序少
+ 一些默认产生的成员函数可以禁用。像赋值操作符和拷贝构造（TODO Demo）
+ A调用B的方法就行了，别用b.f1().f2().f3()，说明B的封装不好。（Demeter 法则）

构造函数

+ 在所有的构造函数初始化所有的数据成员
+ private 构造函数来实现单例模式
+ 优先考虑 深拷贝

为什么使用类：

应该避免的类：

+ 万能类
+ 没有行为的类
+ 动词命名的类 StringBuilder
     

## chp07 高质量的子程序

创建程序的正当理由：

+ 降低复杂度，提供抽象来简化代码
+ 引入中间、易懂的抽象
+ 避免代码重复
+ 支持子类化
+ 隐藏细节
+ 隐藏指针操作
+ 提高可移植性
+ 简化复杂的布尔判断，封进一个函数中
+ 改善性能（放到一个地方优化）
+ 确保所有的子程序都很小
+ 提高可读性

内聚：

+ 功能上的内聚

好的子程序命名

+ 描述所做的事情
+ 尽量精确，避免模糊的字
+ 长度 9-15字符
+ 动宾结构/面向对象就是动词
+ 对仗词
+ 命名规范。遵守规范，前后统一。

子程序的行数：

+ 50-150行
+ 不要超过200行

如何使用子程序参数：

+ 按照输入-修改-输出的顺序排列参数
+ 若干子程序风格保持一致
+ 使用所有的参数
+ 把状态或者出错变量放在最后
+ 不要改变子程序的输入参数。将其用作工作变量。
+ 参数个数7个以内
+ 输入、修改、输出的参数显示命名。in_xxx, m_xxx , out_xxx。
+ 为接口提供维持其抽象的变量列表或者对象。（有时传对象，有时传若干变量 p179）
+ 检查参数类型，必要时使用Assert。

返回值：

+ 检查所有的返回路径
+ 不要返回局部数据的引用或指针。可以将变化记录在类的数据中，然后使用对应的Getter来访问。

宏的替代方案：

+ const 用户定义常量
+ inline
+ template ，以类型安全的方式定义各种标准操作
+ enum 
+ typedef 用户简单的类型替换

内链

+ 节制使用，因为写在.h中，破坏封装


## chp08 防御式编程

在开车的时候，你要承担起保护自己的责任，哪怕别的司机犯错。

Gabage In

+ 检查外部数据
+ 检查函数输入
+ 处理错误输入数据

断言，断言主要用于开发和维护阶段。

下面是C++语言的支持message的断言宏。

	#define ASSERT (condition, message) {						\
		if (condition) {										\
			LogError("Assertion Failed .", condition, message);	\
		}														\
		exit(EXIT_FAILURE);										\
	}															\
	

错误处理技术

+ 返回中立值
+ 换用下一个正确数据
+ 返回前一次相同的结果
+ 换用最接近的合法值
+ 记录日志
+ 返回一个错误码
	+ 设置状态变量的值
	+ 用状态值作为函数的返回值
	+ 抛出一个异常
+ 调用错误处理子程序或对象
+ 显示出错信息
+ 用最妥当的方法在局部处理
+ 关闭程序

健壮性 vs 正确性

高层设计对错误处理的影响。确定一种通用的错误处理策略，是架构层次的设计决策。

请在每一个系统调用后检查错误码。

异常

> 把异常当做正常处理逻辑的一部分，这样的程序都会遭遇可读性和可维护性的问题（意大利面）。

+ 异常表示通知使用方，发生了不可忽略的错误。
+ 只在真正例外的情况下才使用异常。 异常弱化了封装，提高了复杂度。
+ 不能用异常来推卸责任
+ 避免在构造函数和析构函数中抛出异常（C++）
+ 异常要和对应抛出函数的抽象在一个层次
+ Message要全
+ 避免使用空的catch(){}语句
+ 了解函数库可能会抛出的异常（C++）
+ 集中的异常报告中心（就像CloudAtlas代码中统一处理所有SQLException一样）
+ 整个项目使用异常标准一致
+ 考虑异常的替代方案

辅助调试的代码

+ 使用ant、make等工具
+ 使用预处理器，在make的时候加上-DDEBUG参数，然后在代码里 #if defined (DEBUG) #endif

有多少防御式代码保留在产品中

+ 保留检查重要错误的代码
+ 去掉检查细微错误的代码
+ 去掉可以导致程序硬性崩溃的代码。比如丢失用户数据等是不可取的
+ 记录错误信息，方便追问题。日志！
+ 错误消息是可读的、友好的。


## chp09 伪代码编程过程

 




     